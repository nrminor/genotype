/**
 * Comprehensive test data generators for SAM/BAM testing
 *
 * Provides utilities for generating authentic genomic data scenarios
 * including edge cases, malformed data, and real-world sequencing patterns.
 */

import type { CIGARString, MAPQScore, SAMAlignment, SAMFlag, SAMHeader } from "../../src/types";

/**
 * Generate a valid SAM alignment record with realistic defaults
 */
export function createValidSAMAlignment(overrides: Partial<SAMAlignment> = {}): SAMAlignment {
  const defaults: SAMAlignment = {
    format: "sam",
    qname: "read_001",
    flag: 99 as SAMFlag, // Paired, properly mapped, first in pair
    rname: "chr1",
    pos: 1000,
    mapq: 60 as MAPQScore,
    cigar: "150M" as CIGARString,
    rnext: "=",
    pnext: 1200,
    tlen: 350,
    seq: "A".repeat(150),
    qual: "I".repeat(150),
    tags: [
      { tag: "NM", type: "i", value: 0 },
      { tag: "MD", type: "Z", value: "150" },
      { tag: "AS", type: "i", value: 150 },
    ],
  };

  return { ...defaults, ...overrides };
}

/**
 * Generate a valid SAM header record
 */
export function createValidSAMHeader(
  type: "HD" | "SQ" | "RG" | "PG" | "CO",
  overrides: Partial<SAMHeader> = {}
): SAMHeader {
  const fieldDefaults = {
    HD: { VN: "1.6", SO: "coordinate" },
    SQ: { SN: "chr1", LN: "248956422" },
    RG: { ID: "sample1", SM: "sample1", PL: "ILLUMINA" },
    PG: { ID: "bwa", VN: "0.7.17", CL: "bwa mem ref.fa reads.fq" },
    CO: { comment: "Generated by test suite" },
  };

  const defaults: SAMHeader = {
    format: "sam-header",
    type,
    fields: fieldDefaults[type],
  };

  return { ...defaults, ...overrides };
}

/**
 * Generate complex CIGAR strings for testing edge cases
 */
export function generateComplexCIGAR(): string[] {
  return [
    "150M", // Simple match
    "75M1I74M", // Single insertion
    "75M1D74M", // Single deletion
    "10S140M", // Soft clipping at start
    "140M10S", // Soft clipping at end
    "5S70M1I74M5S", // Complex with soft clipping
    "50M100N50M", // Spliced alignment (RNA-seq)
    "25M1I25M1D25M1I25M1D48M", // Multiple indels
    "10H140M10H", // Hard clipping
    "2S48M1I49M1D48M2S", // Mixed operations
    "1000M", // Long read
    "10000M", // Very long read (Nanopore/PacBio)
    "50=1X99=", // Sequence match/mismatch
    "1M1P98M", // Padding (rare but valid)
    "25M50N25M50N50M", // Multiple introns
    "*", // Unmapped
  ];
}

/**
 * Generate long read data (Oxford Nanopore/PacBio style)
 */
export function generateLongReadData(): SAMAlignment {
  const readLength = 15000 + Math.floor(Math.random() * 35000); // 15-50kb
  const sequence = generateRandomSequence(readLength);
  const quality = generateRandomQuality(readLength);

  // Generate complex CIGAR with multiple operations
  const cigarOps = ["M", "I", "D"];
  const cigarParts: string[] = [];
  let remaining = readLength;

  while (remaining > 0) {
    const op = cigarOps[Math.floor(Math.random() * cigarOps.length)];
    const maxLen = Math.min(remaining, 1000 + Math.floor(Math.random() * 2000));
    let len = Math.max(1, Math.floor(Math.random() * maxLen));

    if (op === "M") {
      len = Math.min(len, remaining);
      remaining -= len;
    } else if (op === "I") {
      len = Math.min(len, remaining);
      remaining -= len;
    } else if (op === "D") {
      // Deletions don't consume query sequence
    }

    cigarParts.push(`${len}${op}`);

    if (remaining <= 0) break;
  }

  return createValidSAMAlignment({
    qname: `longread_${Math.floor(Math.random() * 10000)}`,
    flag: 0 as SAMFlag, // Single-end read
    cigar: cigarParts.join("") as CIGARString,
    rnext: "*",
    pnext: 0,
    tlen: 0,
    seq: sequence,
    qual: quality,
    tags: [
      { tag: "NM", type: "i", value: Math.floor(readLength * 0.05) }, // 5% error rate
      { tag: "RG", type: "Z", value: "ONT_run_001" },
    ],
  });
}

/**
 * Generate paired-end sequencing data
 */
export function generatePairedEndData(): [SAMAlignment, SAMAlignment] {
  const readName = `pair_${Math.floor(Math.random() * 100000)}`;
  const templateLength = 300 + Math.floor(Math.random() * 200); // 300-500bp
  const readLength = 150;

  const read1 = createValidSAMAlignment({
    qname: readName,
    flag: 99 as SAMFlag, // Paired, proper pair, first in pair
    pos: 1000,
    tlen: templateLength,
    seq: generateRandomSequence(readLength),
    qual: generateRandomQuality(readLength),
    tags: [
      { tag: "MC", type: "Z", value: "150M" },
      { tag: "RG", type: "Z", value: "PE_sample" },
    ],
  });

  const read2 = createValidSAMAlignment({
    qname: readName,
    flag: 147 as SAMFlag, // Paired, proper pair, second in pair, reverse
    pos: 1000 + templateLength - readLength,
    pnext: 1000,
    tlen: -templateLength,
    seq: generateRandomSequence(readLength),
    qual: generateRandomQuality(readLength),
    tags: [
      { tag: "MC", type: "Z", value: "150M" },
      { tag: "RG", type: "Z", value: "PE_sample" },
    ],
  });

  return [read1, read2];
}

/**
 * Generate RNA-seq data with splice junctions
 */
export function generateRNASeqData(): SAMAlignment {
  const exonLength1 = 50 + Math.floor(Math.random() * 50);
  const intronLength = 1000 + Math.floor(Math.random() * 10000);
  const exonLength2 = 50 + Math.floor(Math.random() * 50);

  const totalReadLength = exonLength1 + exonLength2;
  const cigar = `${exonLength1}M${intronLength}N${exonLength2}M` as CIGARString;

  return createValidSAMAlignment({
    qname: `rnaseq_${Math.floor(Math.random() * 10000)}`,
    cigar,
    seq: generateRandomSequence(totalReadLength),
    qual: generateRandomQuality(totalReadLength),
    tags: [
      { tag: "NH", type: "i", value: 1 }, // Number of hits
      { tag: "HI", type: "i", value: 1 }, // Hit index
      { tag: "NM", type: "i", value: 0 },
    ],
  });
}

/**
 * Generate malformed SAM data for error testing
 */
export function generateMalformedSAMData(): string[] {
  return [
    // Insufficient fields
    "read1\t99\tchr1\t1000",
    // Invalid flag
    "read1\tNOT_A_NUMBER\tchr1\t1000\t60\t150M\t=\t1200\t350\tACGT\tIIII",
    // Invalid position
    "read1\t99\tchr1\tNOT_A_NUMBER\t60\t150M\t=\t1200\t350\tACGT\tIIII",
    // Invalid MAPQ
    "read1\t99\tchr1\t1000\tNOT_A_NUMBER\t150M\t=\t1200\t350\tACGT\tIIII",
    // Invalid CIGAR
    "read1\t99\tchr1\t1000\t60\t150Z\t=\t1200\t350\tACGT\tIIII",
    // Sequence/quality mismatch
    "read1\t99\tchr1\t1000\t60\t150M\t=\t1200\t350\tACGT\tIIIIIIII",
    // Invalid tag format
    "read1\t99\tchr1\t1000\t60\t150M\t=\t1200\t350\tACGT\tIIII\tINVALID",
    // Flag out of range
    "read1\t2048\tchr1\t1000\t60\t150M\t=\t1200\t350\tACGT\tIIII",
    // MAPQ out of range
    "read1\t99\tchr1\t1000\t256\t150M\t=\t1200\t350\tACGT\tIIII",
    // Empty header
    "@",
    // Invalid header type
    "@XX\tVN:1.6",
    // Malformed header field
    "@HD\tINVALID_FIELD",
  ];
}

/**
 * Generate edge case data for boundary testing
 */
export function generateEdgeCaseData(): SAMAlignment[] {
  return [
    // Unmapped read
    createValidSAMAlignment({
      flag: 4 as SAMFlag,
      rname: "*",
      pos: 0,
      mapq: 0 as MAPQScore,
      cigar: "*" as CIGARString,
      seq: "*",
      qual: "*",
    }),

    // Maximum coordinates
    createValidSAMAlignment({
      pos: 248956422, // Length of chr1
      pnext: 248956422,
    }),

    // Zero template length
    createValidSAMAlignment({
      tlen: 0,
    }),

    // Negative template length
    createValidSAMAlignment({
      tlen: -350,
    }),

    // All flags set
    createValidSAMAlignment({
      flag: 2047 as SAMFlag, // All 11 bits set
    }),

    // Minimum MAPQ
    createValidSAMAlignment({
      mapq: 0 as MAPQScore,
    }),

    // Maximum MAPQ
    createValidSAMAlignment({
      mapq: 255 as MAPQScore,
    }),

    // Very long sequence name
    createValidSAMAlignment({
      qname: "a".repeat(254), // SAM spec allows up to 254 characters
    }),
  ];
}

/**
 * Generate random DNA sequence
 */
export function generateRandomSequence(length: number): string {
  const bases = ["A", "C", "G", "T"];
  return Array.from({ length }, () => bases[Math.floor(Math.random() * bases.length)]).join("");
}

/**
 * Generate random quality scores (Phred+33)
 */
export function generateRandomQuality(length: number): string {
  // Quality scores from 2-40 (!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHI)
  const minQual = 33 + 2; // Phred+33 + quality 2
  const maxQual = 33 + 40; // Phred+33 + quality 40

  return Array.from({ length }, () =>
    String.fromCharCode(minQual + Math.floor(Math.random() * (maxQual - minQual + 1)))
  ).join("");
}

/**
 * Generate synthetic BAM binary data for testing
 */
export function generateSyntheticBAMData(): Uint8Array {
  // Create minimal valid BAM file with header only
  const buffer = new ArrayBuffer(1024);
  const view = new DataView(buffer);
  let offset = 0;

  // BAM magic bytes
  view.setUint8(offset++, 0x42); // 'B'
  view.setUint8(offset++, 0x41); // 'A'
  view.setUint8(offset++, 0x4d); // 'M'
  view.setUint8(offset++, 0x01); // Version

  // SAM header length (0 for minimal)
  view.setInt32(offset, 0, true);
  offset += 4;

  // Number of references (1)
  view.setInt32(offset, 1, true);
  offset += 4;

  // Reference 1: chr1
  const refName = "chr1\0";
  view.setInt32(offset, refName.length, true);
  offset += 4;

  for (let i = 0; i < refName.length; i++) {
    view.setUint8(offset++, refName.charCodeAt(i));
  }

  // Reference length
  view.setInt32(offset, 248956422, true);
  offset += 4;

  return new Uint8Array(buffer, 0, offset);
}

/**
 * Performance test data generator
 */
export function generateLargeDataset(numRecords: number): string {
  const headers = [
    createValidSAMHeader("HD"),
    createValidSAMHeader("SQ"),
    createValidSAMHeader("RG"),
  ];

  const headerLines = headers.map((h) => {
    const fields = Object.entries(h.fields)
      .map(([k, v]) => `${k}:${v}`)
      .join("\t");
    return `@${h.type}\t${fields}`;
  });

  const alignmentLines: string[] = [];
  for (let i = 0; i < numRecords; i++) {
    const alignment = createValidSAMAlignment({
      qname: `read_${i + 1}`,
      pos: 1000 + i * 200,
      pnext: 1000 + i * 200 + 200,
      seq: generateRandomSequence(150),
      qual: generateRandomQuality(150),
    });

    const fields = [
      alignment.qname,
      alignment.flag.toString(),
      alignment.rname,
      alignment.pos.toString(),
      alignment.mapq.toString(),
      alignment.cigar,
      alignment.rnext,
      alignment.pnext.toString(),
      alignment.tlen.toString(),
      alignment.seq,
      alignment.qual,
    ];

    if (alignment.tags) {
      alignment.tags.forEach((tag) => {
        fields.push(`${tag.tag}:${tag.type}:${tag.value}`);
      });
    }

    alignmentLines.push(fields.join("\t"));
  }

  return [...headerLines, ...alignmentLines].join("\n");
}

/**
 * Create test fixtures for different sequencing platforms
 */
export function createPlatformSpecificData() {
  return {
    illumina: {
      readLength: 150,
      insertSize: 350,
      errorRate: 0.001,
      platform: "ILLUMINA",
    },
    nanopore: {
      readLength: 25000,
      insertSize: 0, // Single-end
      errorRate: 0.05,
      platform: "ONT",
    },
    pacbio: {
      readLength: 15000,
      insertSize: 0, // Single-end
      errorRate: 0.03,
      platform: "PACBIO",
    },
  };
}
